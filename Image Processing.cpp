/*
    This is an image processing app.
    When you start the program it asks you to load an image from the assets folder you write the name and the extension of the image (image.jpg).
    Then a punch of filters appears, you can apply any filter you want, and you can apply filters one by one.
    At any point you can save the image with any extension and in any folder even it does not exist.

    The App is colorful and eyes friendly. it's not only about the look.
    The app follows Object-Oriented Programming paradigm.
    It is scalable, and you can implement any filter smoothly without changing other classes.


    20242110 - Hamza Mohammad Zaki - Filters that have been assigned to Hamza by our beloved doctor (GreyScale, Merge, Darken and Lighten, Edge Detection)
    20242295 - Mohammad Abdulhakim Ramadan - Filters that have been assigned to Mohammad by our beloved doctor (White and Black, Flip, Crop, Resizing, Oil Painting, Infrared, Painting, Bloody, Sky, Grass )
    20240588 - Mostafa Ahmed Ali - Filters that have been assigned to Mostafa by our beloved doctor (Invert, Rotate, Frame, Blur, Sunlight, Night, Old TV, Skew)

    Repo: https://github.com/mohammadabdulhakim/cpp-image-processor
    Video:https://drive.google.com/file/d/1JwfZ4EaOa0lDDdudM1ykVUVurc86tPN4/view?usp=drive_link
    Doc: https://docs.google.com/document/d/1qCHJ92_c90hBn0wo34rJ349e9NXzKGfr/edit?usp=sharing&ouid=104606776738113898703&rtpof=true&sd=true

    Competition Drive: https://drive.google.com/drive/folders/1YQpSNy2T5i5xhCbJqXt8GEbWl3ScDerE

*/
#define _CRT_SECURE_NO_WARNINGS
#define NOMINMAX
#include <complex>
#include <map>
#include<stack>
#include <memory>
#include "Image_Class.h"
#include <stdexcept>
#include <vector>
#include<cmath>
#include<unordered_map>
#define M_PI 3.14159265359
#include "iostream"
#include <filesystem>
#include<algorithm>
#include <windows.h>
#include"Filter.h"
#include "SunlightFilter.h"
#include "NightFilter.h"
#include "BlurFilter.h"
#include "SkewingFilter.h"
#include"TVFilter.h"
#include"GreyFilter.h"
#include"WBFilter.h"
#include"MergeFilter.h"
#include"FlipFilter.h"
#include"RotateFilter.h"
#include"InvertFilter.h"
#include"BrightnessFilter.h"
#include"CropFiter.h"
#include "ResizeFilter.h"
#include "OilPaintingFilter.h"
#include "PaintingFilter.h"
#include "InfraredFilter.h"
#include "BloodyFilter.h"
#include "SkyFilter.h"
#include "GrassFilter.h"
#include "FrameFilter.h"
#include "EdgeDetectionFilter.h"
#include "ConvolutionFilter.h"
#include "SharpenFilter.h"
#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define CYAN    "\033[36m"
#define BOLD    "\033[1m"
namespace fs = std::filesystem;
using namespace std;
# define ll long long 

string getImagePath(string imgName) {
    return ("assets/" + imgName);
}
void enableANSI() { // This Function Generated By AI to Apply Ansi Colors in terminals
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    DWORD dwMode = 0;
    GetConsoleMode(hOut, &dwMode);
    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    SetConsoleMode(hOut, dwMode);
}
class Menu {
    vector<pair<string, shared_ptr<Filter>>> filters;
    string res;
    bool isActive = true;

public:
    Menu(vector<pair<string, shared_ptr<Filter>>>& filters) : filters(filters) {}

    void welcomeMsg() {
        cout << CYAN << "====================\n";
        cout << RESET << BOLD << "    Image Filters    \n";
        cout << RESET << CYAN << "=====================\n";
    }

    void showMenuOptions(bool fileLoaded) {
        cout << RESET << GREEN << "[l] Load Image\n";
        if (fileLoaded) {
            cout << CYAN << "=====================\n";
            cout << RESET << BOLD << "    Choose Filters    \n";
            cout << RESET << CYAN << "======================\n" << RESET;

            auto it = filters.begin();
            while (it != filters.end()) {
                cout << "\t [" << it->first << "] " << it->second->getName() << " Filter.\n";
                ++it;
            }

            cout << "\t[s] Save the Image.\n";
            cout << "\t[u] Undo \t [r] Redo\n";
        }
        cout << RESET << RED << "[0] Exit\n" << RESET;
        cout << "-------------------------------\n";
    }

    void invalidOptionMsg() {
        cout << RED << "Invalid option \n" << RESET;
        cout << YELLOW << "Plz Enter Valid option";
        cout << "\n\n";
    }

    bool getIsActive() { return isActive; }

    void setIsActive(bool newIsActive) { isActive = newIsActive; }

    void setResponse() {
        cout << BOLD << GREEN << "# " << RESET;
        cin >> res;
        cout << '\n';
    }

    string getResponse() { return res; }
};
class CurrentImage
{
    bool isLoaded = false;
    stack<Image> Undo;
    stack<Image> Redo;

public:
    Image img;

    void filterApplied() {
        Undo.push(img);
    }

    void load()
    {
        if (isLoaded && !Undo.empty())
        {
            char OP;
            cout << CYAN << "Do you want keep your changing ?  (y)es or (n)o: " << RESET << endl;
            cin >> OP;
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            if (OP == 'y')
            {
                save();
                cout << GREEN << "Image changed successfully \n" << RESET;
            }
        }
        string imgName;
        cout << CYAN << "Please enter image name you want to apply filter on: " << RESET << GREEN << BOLD;
        cin >> ws;
        getline(cin, imgName);
        cout << "\n\n" << RESET;
        img.loadNewImage(getImagePath(imgName));
        setIsLoaded(true);

        Undo = stack<Image>();
        Redo = stack<Image>();
    }

    void save()
    {
        cout << YELLOW << "Enter the name of the new image : " << RESET;
        string imgName;
        cin >> imgName;

        if (!fs::exists("output"))
            fs::create_directory("output");

        img.saveImage("output/" + imgName);
        cout << GREEN << "Your image has been saved successfully!\n" << RESET;
    }

    void undo()
    {
        if (!Undo.empty())
        {
            Redo.push(img);
            img = Undo.top();
            Undo.pop();
        }
        else
        {
            cout << RED << "No more steps to undo.\n" << RESET;
        }
    }

    void redo()
    {
        if (!Redo.empty())
        {
            Undo.push(img);
            img = Redo.top();
            Redo.pop();
        }
        else
        {
            cout << RED << "No more steps to redo.\n" << RESET;
        }
    }

    bool getIsLoaded() const
    {
        return isLoaded;
    }

    void setIsLoaded(bool newIsLoaded)
    {
        isLoaded = newIsLoaded;
    }
};

int main()
{
    enableANSI();
    CurrentImage currentImage;
    Image img;
    vector<pair<string, shared_ptr<Filter>>> filters = {
        {GreyFilter::getId(), make_shared<GreyFilter>(currentImage.img)},
        {WBFilter::getId(), make_shared<WBFilter>(currentImage.img)},
        {InvertFilter::getId(), make_shared<InvertFilter>(currentImage.img)},
        {MergeFilter::getId(), make_shared<MergeFilter>(currentImage.img)},
        {FlipFilter::getId(), make_shared<FlipFilter>(currentImage.img)},
        {RotateFilter::getId(), make_shared<RotateFilter>(currentImage.img)},
        {BrightnessFilter::getId(), make_shared<BrightnessFilter>(currentImage.img)},
        {CropFilter::getId(), make_shared<CropFilter>(currentImage.img)},
        {FrameFilter::getId(), make_shared<FrameFilter>(currentImage.img)},
        {EdgeDetectionFilter::getId(),make_shared<EdgeDetectionFilter>(currentImage.img)},
        {ResizeFilter::getId(), make_shared<ResizeFilter>(currentImage.img)},
        {BlurFilter::getId(), make_shared<BlurFilter>(currentImage.img)},
        {SunlightFilter::getId(), make_shared<SunlightFilter>(currentImage.img)},
        {OilPaintingFilter::getId(), make_shared<OilPaintingFilter>(currentImage.img)},
        {TVFilter::getId(), make_shared<TVFilter>(currentImage.img)},
        {NightFilter::getId(), make_shared<NightFilter>(currentImage.img)},
        {InfraredFilter::getId(), make_shared<InfraredFilter>(currentImage.img)},
        {SkewingFilter::getId(), make_shared<SkewingFilter>(currentImage.img)},
        {BloodyFilter::getId(), make_shared<BloodyFilter>(currentImage.img)},
        {GrassFilter::getId(),make_shared<GrassFilter>(currentImage.img)},
        {SkyFilter::getId(),make_shared<SkyFilter>(currentImage.img)},
        {PaintingFilter::getId(), make_shared<PaintingFilter>(currentImage.img)},
    };

    Menu menu(filters);
    menu.welcomeMsg();

    while (menu.getIsActive())
    {
        menu.showMenuOptions(currentImage.getIsLoaded());
        menu.setResponse();

        string res = menu.getResponse();

        if (res == "l")
        {
            currentImage.load();
        }
        else if (res == "s" && currentImage.getIsLoaded())
        {
            currentImage.save();
        }
        else if (res == "u" && currentImage.getIsLoaded())
        {
            currentImage.undo();
        }
        else if (res == "r" && currentImage.getIsLoaded())
        {
            currentImage.redo();
        }
        else if (res == "0")
        {
            menu.setIsActive(false);
        }
        else if (currentImage.getIsLoaded())
        {
            bool noFilterWithRes = true;
            for (auto& filter : filters) {
                if (filter.first == res) {
                    currentImage.filterApplied();
                    filter.second->getNeeds();
                    filter.second->apply();
                    noFilterWithRes = false;
                }
            }

            if (noFilterWithRes) menu.invalidOptionMsg();
        }
        else
        {
            menu.invalidOptionMsg();
        }
    }
    return 0;
}